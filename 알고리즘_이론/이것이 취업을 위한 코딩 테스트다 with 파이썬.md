# 이것이 취업을 위한 코딩 테스트다 with 파이썬

## 1. 코테대비용 알고리즘 개요

#### 자신만의 소스코드 관리하기

- 자주 사용되는 알고리즘 코드를 노트화

#### 출제 빈도가 높은 알고리즘 유형

- 그리디
- 구현
- DFS / BFS
- 다이나믹 프로그래밍
- 문자열

#### 복잡도

: 알고리즘 성능을 나타내는 척도

- 시간복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
- 공간 복잡도: 특정한 크기의 입력에 대하여 메모리 사용량 분석

​	=> 복잡도가 낮을수록 좋은 알고리즘이다

#### 빅오표기법

: 가장 빠르게 증가하는 항만을 고려하는 표기법. 함수의 상항만을 나타내게 됨

ex ) 연산 횟수가 3N^3 + 5N^2 + 1,000,000 => 차수가 가장 큰 항만 남기므로 O(N^3)

- O(1) : 상수시간 -> 상수번의 연산만 수행
- O(log N) : 로그시간 -> logN에 비례
- O(N) : 선형 시간 -> 데이터의 크기가 N
- O(NlogN) : 로그 선형시간
- O(N^2) : 이차시간
- O(N^3) : 삼차시간
- O(2^n) : 지수 시간

#### N개의 데이터의 합을 계산하는 프로그램 예제

```python
array = [3, 5, 1, 2, 4]
summary = 0
# 모든 데이터를 하나씩 확인하며 합계를 계산
for x in array:# N크기에 영향받는 부분 
    summary += x
# 시간복잡도 O(N)
```

=> 총 데이터의 갯수만큼 선형적으로 수행시간이 비례한다.

- 2중 반복문

```python
array = [3, 5, 1, 2, 4]
for i in array:
    for j in array:
        temp = i*j
        print(temp)
# 시간복잡도 O(N^2)
```

=> 모든 이중반복문의 시간복잡도가 O(N^2)은 아니다.

=> 소스코드가 내부적으로 다른 함수를 호출한다면 그 함수의 시간복잡도도 고려해야 한다.

- 연산 횟수가 5억 이상일 시
  - C언어 기준 1~3초 소요 / Python 기준 5-15초 소요(pypy는 좀 더 빠르다)

- O(N^3)의 알고리즘을 설계한 경우 N의 값이 5,000이 넘는다면?
  - 5000x5000x5000 => 1250억(2500초)
- 코테 문제에서 별도 시간제한 명시가 없다면 5초 정도로 생각하자.



- 시간 제한이 1초인 문제를 만났을 때:

  N < 500 : O(N^3)

  N < 200 : O(N^2)

  N < 100,000 : O(NlogN)

  N < 10,000,000 : O(N)

  

#### 알고리즘 문제 해결 과정

1. 지문을 꼼꼼하게 읽고 컴퓨터적 사고를 통해 어떤 과정에서 뭐가 필요한지 잘게 쪼개 생각한다. 문제를 최대한 간결하게 정리

2. 요구사항(복잡도 분석)을 분석해서 어느 정도 성능으로 동작하는 알고리즘을 작성해야 할지 생각해 본다.

3. 문제 해결을 위한 아이디어 찾기

4. 소스코드 설계 및 코딩

   => 대부분 핵심 아이디어를 캐치한다면 간결하게 코드를 작성할 수 있는 형태이다!

   - **생각나는 내용을 바로 치기보다 먼저 문제를 온전히 이해하고 어떤식으로 코드를 작성할지 정리하기**
   - **나는 이 문제를 창의적으로 풀 수 있다고 세뇌!!**

```python
import time
start_time = time.time() # 측정 시작
end_time = time.time() # 측정 종료
print(end_time - start_time) # 수행 시간 출력
```



## 2. 파이썬 문법 및 자료구조

#### 자료형

- 자료형에 대한 이해는 프로그래밍의 첫걸음!
- 정수형, 실수형, 복소수형, 문자열, 리스트, 튜플, 사전

#### 실수형

: 소수점 아래 데이터를 포함하는 수 자료형

- 0이 포함되면 생략O (0.7 => .7)

- e, E를 이용한 지수 표현 방식

  - e, E 다음에 오는 수는 10의 지수부

    ex) 1e9 = 10의 9제곱

    ​		유효숫자e지수 = 유효숫자x10지수

    => 임의의 큰 수 만들 때 자주 사용

- IEEE754 표준에서는 실수형을 저장하기 위해 4 또는 8byte의 고정된 크기의 메모리를 할당했다. => 컴퓨터 시스템은 실수 정보를 표현하는 정확도에 한계가 있다.

  ex) 10진수 체계 : 0.3 + 0.6 = 0.9 

  ex) 2진수 체계 : 0.9 표현 방법 X => 최대한 0.9와 가깝게 표현하지만 오차 발생

  => 개발 과정에서 실수값을 제대로 비교하지 못해 원하는 결과를 얻지 못할 수 있다. 

- round()함수 사용

  123.456 -> round(123.456, 2) -> 123.46(둘째자리에서 출력->셋째자리에서 반올림)

#### 수 자료형의 연산

- 나누기 연산자(/) : 나누어진 결과를 실수형으로 반환
- 나머지 연산자(%) : 정수형
- 몫 연산자(//) : 정수형



#### 리스트 자료형 (=vector)

```python
# nxm크기의 2차원 리스트
n = 4, m = 3
array = [[0]*m for _ in range(n)]

# 주의!
n = 4
m = 3
array = [[0]*m]*n 
# nxm 리스트가 잘 생성은 되지만,
# 내부 객체 하나의 값을 바꾸면 내부 리스트가 모두 같은 개체로 인식된다.
array[1][1] = 5 # 55555 다바뀜
```

- 리스트 메서드 시간복잡도

  - append() : O(1)

  - sort() : O(NlogN)

  - reverse() : O(N)

  - insert() : O(N)

  - count() : O(N)

  - remove() : O(N)

    - 특정 원소의 존재 유무만을 체크하고자 할 때 효과적이다.

      ```python
      a = [1, 2, 3, 3, 4, 5, 5, 5]
      remove_set = {3, 5}
      result = [i for i in a if i not in remove_set]
      ```

      

#### 함수

- function 밖에 있는 변수 참조 시 global 키워드로 명시

- 단순히 print처럼 참조만 하는 경우는 전역변수 써도 오류 X

- 리스트가 선언되어 있을 때 함수 내에서 리스트의 메서드를 호출하는 경우->상관X

- 전역변수와 지역변수가 동일한 이름으로 선언되어 있다면 지역변수를 우선으로/

  함수 밖에서는 전역변수 우선

- 함수는 여러 개의 반환값을 return 할 수 있다. = 패킹

- 함수를 호출할 때 반환된 값들을 차례대로 특정 변수에 담는 것 = 언패킹

#### 람다 표현식

: 특정한 기능을 수행하는 함수를 한 줄에 작성 가능하다

```python
def add(a, b):
    return a + b
# 일반적인 add()메서드 사용
print(add(3, 7))

# 람다 표현식으로 구현한 add()메서드
print((lambda a, b: a + b)(3, 7))
# 함수를 한 줄에 출력할 수 있다

# 내장 함수에서 자주 사용되는 람다 함수
array = [('홍길동', 50),('이순신', 32),('아무개', 74)]

def my_key(x):
    return x[1]
print(sorted(array, key=my_key))
print(sorted(array, key=lambda x: x[1]))
# key 속성으로 두번째 원소를 기준으로 정렬을 수행하도록 하는 lambda식

# 결과
[('이순신', 32),('홍길동', 50),('아무개', 74)]
[('이순신', 32),('홍길동', 50),('아무개', 74)]


# 여러 개의 리스트에 적용
list1 = [1, 2, 3, 4, 5]
list2 = [6, 7, 8, 9, 10]

result = map(lambda a, b: a + b, list1, list2)
# map 함수: 각각의 원소에 어떤 함수를 적용하고자 할 때 사용
print(list(result))
#결과
[7, 9, 11, 13, 15]
```



#### 파이썬 표준 라이브러리

- 내장 함수: 기본 입출력 함수, 정렬함수 등 기본적인 함수

  ```python
  # eval()
  result = eval("(3+5)*7")
  print(result)
  # 사람의 입장에서 표현된 식을 계산한 결과를 반환해주는 함수
  
  # sorted() - 리스트 같이 반복 가능한 객체가 들어왔을 때 정렬하여 반환
  result = sorted([9, 1, 8, 5, 4])
  reverse_result = sorted([9, 1, 8, 5, 4], reverse=True)
  print(result)
  print(reverse_result)
  ```

  

- itertools: 반복되는 형태의 데이터를 처리하기 위한 기능 제공 - **순열, 조합**

  ```python
  # 순열: 서로 다른 n개에서 서로 다른 r개를 선택하여 일렬로 나열하는 것
  # 조합: 서로 다른 n개에서 순서에 상관 없이 서로 다른 r개를 선택하는 것
  from itertools import permutations
  data = ['A', 'B', 'C'] # 데이터 준비
  result = list(combinations(data, 3)) # 모든 순열 구하기
  print(result)
  
  from itertools import combinations # 모든 조합 구하기
  data = ['A', 'B', 'C']
  result = list(combinations(data, 3))
  print(result)
  
  # 중복 허용하여 2개 뽑는 모든 순열
  from itertools import product
  result = list(product(data, repeat=2))
  
  # 중복 허용하여 2개를 뽑는 모든 조합
  from itertools import combinations_with_replacement
  result = list(combinations_with_replacement(data, 2))
  ```

- heapq: 힙(Heap)자료구조 제공 -> 일반적으로 우선순위 큐 기능 구현하기 위해 사용

- bisect: 이진탐색 기능 제공

- collections: 덱(deque), 카운터(Counter) 등의 유용한 자료구조 포함

  ```python
  from collections import Counter
  counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])
  
  print(counter['blue']) # blue횟수 출력
  print(coutner['green']) # green 횟수 출력
  print(dict(counter)) # 사전 자료형으로 반환
  
  # 실행 결과
  3
  1
  {'red':2, 'blue': 3, 'green': 1}
  ```

- math : 필수적인 수학적 기능 제공 - 팩토리얼, 제곱근, 최대공약수, 삼각함수, 파이 등

  ```python
  # 최대공약수를 구해야 할때는 math 라이브러리의 gcd() 함수를 이용한다.
  import math
  
  # 최소 공배수(LCM)를 구하는 함수
  def lcm(a, b):
      return a*b // math.gcd(a, b)
  a = 21
  b = 14
  print(math.gcd(21, 14)) # 최대공약수 gcd
  print(lcm(21, 14)) # 최소공배수
  
  # 실행 결과
  7
  42
  ```




## 3. 그리디 알고리즘(탐욕법)

- 현재 상황에서 지금 당장 좋은 것만 고르는 방법

- 정당성 분석이 중요 - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토한다.

- 동전 문제

  - 정당성 분석

    가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는?

    가지고 있는 동전 중 큰 단위가 항상 작은 단위의 배수이므로

    작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문

    800원 거슬러 주어야 하는데 화폐 단위가 500, 400, 100원이라면? 이 방법을 사용해서 최적의 해를 보장할 수 없다.

  - 문제 풀이를 위한 최소한의 아이디어를 떠올리고, 정당성 분석을 해야 한다.

  ```python
  n = 1260
  count = 0
  array = [500, 100, 50, 10]
  
  for coin in array:
      count += n//coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
      n %= coin
  print(count)
  ```

  - 시간복잡도: 화폐의 종류가 K일 때, 시간복잡도 O(K)

- 1이 될 때까지

​		빼기 또는 나누기를 사용해서 1이 될때까지 걸리는 최소 횟수



​		

































